import random
import time

nodes = []

weights = [0.7381670835348864, 0.966421696420555, 1.1645883302693147, 0.6867364094842944, 0.7093605930594206, 0.09453618309571105, 0.436568081549057, 0.8692457668910514, -0.3499786493000495, 0.09772918365262097, 0.049272737430991434, -0.4902997410632403, 0.40143592394744976, -0.10875891195264331, -0.11834338291562763, 0.21956821680147545, -0.08565178205700809, 0.7307080033469681, -0.06137729434015615, 0.17837341729397463, 1.8631970391733086, 0.21210330968273458, -0.003793699185145464, -0.14701763314586588, -0.10076829115001534, 1.2944509408659743, -0.022887851934802896, 0.3000926421672507, -0.12648526406182878, -0.005144942183920195, 0.9524069929682912, 0.6627076939251538, 1.470652157605451, 0.9884287058559821, 1.2820261555953305, 0.9546911463779651, 0.5892061746215767, -0.5691216142130047, 0.5279363840716856, 0.5837414746346976, 0.2915503181452413, 0.9336109062783965, 0.08562674717139418, 0.09046488065583708, 0.581646496828671, -0.14435122402159228, 0.7930693797789581, 0.43272888295279305, 0.8859323388067306, -0.5054430474034497, 0.3461498586418269, -0.1528020312464703, 1.0245540539251283, 0.9599888066092508, 0.654256603376258, -0.7687772710914459, 0.30655920335780595, 0.9649036005260068, 0.28297803812233513, 0.404807233641611, 0.5409136206639954, 0.5261190574221299, 0.5508019628756814, 0.6870868902411311, -0.17927578105538805, 0.8974052050586788, 0.6884334316903754, 1.0363021566316444, 1.5867139213100572, 1.450750430123326, 0.5980421373365218, 0.874406648339469, 1.176717735662826, 0.9106526784086127, 0.002511093068380766, 0.5656740457889738, 0.006977104348172619, 0.4925655791800132, 0.19570798268505932, 0.8398497936275086, 0.7212277764351197, 0.9454200333509357, 0.32560961018388096, 0.09843955143633272, 0.7228592778070783, -0.30673682568776234, 0.2897345648993443, 0.1502056411488324, 0.23830520247797315, 0.5412786928966431, 0.11543223613020535, -0.07199924949475571, 0.3455200955312208, -0.024459793643768574, -0.035872022002167464, 0.5215964944680997, 0.18657066914845188, 0.9156891212404024, 0.3168785732937771, 1.4227556032598, 0.12336132372580315, 0.010417170610611698, 0.6839686611106792, 0.8554689275138347, 0.9775704169606777, 1.1752226070310055, 1.113598908074983, 0.8537463592935577, 0.9953709043426952, 0.18285799756956161, -0.5659539224596548, 0.423048094993813, 0.5582254773759258, -0.5772302028876843, 1.0085160700246065, 0.09872430131622022, 0.050947212395201745, 0.14955237591228654, 0.16413009982298118, -0.9513616356548312, 0.5582855235483816, -0.04455208160847828, 0.6636113816473338, 0.6077714648781779, 0.4375409974452578, 1.3907508629007992, 0.7129574787649385, 0.9500045612318353, 0.49342339182050804, 0.5375076676792725, 0.006203416891586475, 0.6830445591524574, 0.5588860132348662, 0.369164689307324, 0.9818945192044809, -0.04207214473688856, -0.1763757009476876, 0.8877826045350576, 1.2034710545974772, 1.0097975500973764, 1.1029985602832257, 1.3564385952074387, 1.019048788066126, 0.7378864089719546, 0.7919503706264576, 0.8388573016624917, 1.0511225961957038, 0.4657513034385521, 0.636920668689367, 0.584651878399906, 0.7732030462250262, 0.41678066324494634, 1.2078415294348395, 0.4161017876852258, 1.057427221115036, 0.9761757241083893, 0.6047773092856259, 1.1740004832994526, 1.0472960834200364, 1.6111047402222236, 0.886338431752107, 1.192323134196377, 0.6190683973953147, 1.0218509142427947, 1.1129039886628105, 0.9296382035611721, 1.010772969925134, 0.641100969519089, 0.5203531701099336, 0.23516338835030876, 0.3744031547589689, -0.033983578688893026, -0.017097478869431186, -0.09803743365728232, 0.7248807312669309, 0.7339409127261407, 0.9654718936564147, 0.7572655595301702, 0.854833740121927, 0.859790738069011]



weights_trial = []
loss_best = 100000000000000
itC = 0
species = 0
data_examples = 1000

# 6x6 neural network with a bias node for each layer. Rectified linear function will be used.


len_weights = 6*6*5
for i in range(0, len_weights):
    #weights.append(1)
    weights_trial.append(1)

len_nodes = 6*6
for i in range(0,len_nodes):
    nodes.append(0)



def sigmoid(x):
    if(x > 0):
        return x
    else:
        return 0


def ff(x_in, y_in, weights_in, nodes_in):
    nodes_in[0] = 1
    nodes_in[1] = x_in
    nodes_in[2] = y_in
    nodes_in[3] = 1
    nodes_in[4] = 1
    nodes_in[5] = 1

    for i in range(6,len_nodes):
        if(i % 6 == 0):
            nodes_in[i] = 1
        else:
            nodes_in[i] = 0
            for j in range(0, 6):
                # Add and weight all nodes in previous layer
                node_index = j + (i - i % 6) - 6
                weight_index = (i - 7) * 6 + j
                #print("node " + str(node_index) + " connected by " + str(weight_index) + " to " + str(i))
                nodes_in[i] += nodes_in[node_index] * weights_in[weight_index]
            nodes_in[i] = sigmoid(nodes[i])
    return nodes_in[-1]

#print(ff(1, 1, weights, nodes))

def extract_numbers_from_file(file_path):
    numbers = []
    try:
        with open(file_path, 'r') as file:
            for i, line in enumerate(file):
                if i >= 1000:  # Process only the first 1000 lines
                    break

                parts = line.split()  # Split the line into parts
                
                # Extract and store the first three numbers
                try:
                    first_three_numbers = [float(parts[j]) for j in range(3)]
                    numbers.append(first_three_numbers)
                except (IndexError, ValueError):
                    print(f"Line {i + 1} is malformed or doesn't contain enough numbers.")

    except FileNotFoundError:
        print(f"File not found: {file_path}")

    return numbers

# Example usage
file_path = 'train_data.txt'  # Replace with your file path
extracted_numbers = extract_numbers_from_file(file_path)
#print(extracted_numbers)


def loss(nodes_in, weights_in):
    sum = 0
    for i in range(0, data_examples):
        x = extracted_numbers[i][0]
        y = extracted_numbers[i][1]
        a = extracted_numbers[i][2]
        a_guess = ff(x, y, weights_in, nodes_in)
        loss = ((a - a_guess) ** 2) / data_examples * 100
        sum += loss

    return sum

#print(loss(nodes, weights))

while True:
    #print(loss(nodes, weights))
    for i in range(0, len_weights):
        weights_trial[i] = weights[i]
    random_mag = 10 ** random.randint(-11, -1)
    for i in range(0, len_weights):
        if(random.uniform(0, 1) < 2 / len_weights):
            weights_trial[i] += random.uniform(-1,1) * random_mag
    
    #print(weights_trial)
    loss_trial = loss(nodes, weights_trial)
    if(loss_trial < loss_best):
        loss_best = loss_trial
        print("\n\n\n\n" + str(weights_trial))
        print("\n\n" + str(loss_best))
        for i in range(0, len_weights):
            weights[i] = weights_trial[i]

        species += 1
    itC += 1





