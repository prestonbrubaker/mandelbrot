import random
import time

nodes = []

weights = [0.795169668695426, 0.9170275210650424, 1.3107023564507663, 0.7104346928461952, 0.7237289062228676, 0.09994183830779585, 0.4617503741070673, 1.042248557523348, -0.4492105350436189, 0.06575247159218743, -0.05049674783104566, -0.5086524698826997, 0.351988494486154, 0.278026305682179, 0.5239460820047643, 0.32277950988905535, -0.0863231191354061, 0.781482507051616, -0.05858738664316865, -0.027362823248759178, 1.8067235840961962, 0.152832772348493, -0.01630261960910104, -0.1625243246114717, -0.08993629711656476, 1.2693768026460144, 0.014737447194331984, 0.2814322178712977, -0.13418562059893852, -0.015512521054029699, 0.998344017274475, 0.8201132225174284, 2.0320315679503986, 0.8636847181333436, 1.1632164261547855, 0.9289427418897712, 0.6204365361248503, -0.48342148579910593, 0.289941354446115, 0.600534661124289, 0.24901142892778297, 0.9608282497766956, 0.0716912325694677, 0.1411442017834522, 0.7200512765514532, -0.13304884517355234, 0.6788436300375947, 0.21430436980020875, 0.8440085250365834, -0.5294572715735785, 0.29924574835484247, -0.15787092760165117, 0.9563673571067959, 1.2006460337641196, 0.7547832895232306, -0.732277453562868, 0.5125734876366496, 1.0188576638869733, -0.07116511063207565, 0.47726734184160263, 0.6602490837318472, 0.4944188637362837, 0.004793563782471394, 0.6703010760515095, 0.3319876840484419, 1.1459270737317675, 0.7531643871074535, 1.1622252784787694, 1.5177252213919903, 1.4440472318911999, 0.5253166884193345, 1.0964482791261454, 1.19379497461619, 1.2473540416625675, 0.053485208374965114, -0.06217538858109729, 0.42716261505834197, 0.3451399073894859, 0.24992646056883644, 0.05995605236215275, 0.5455403601369634, 2.2019577656440266, 0.2250150205314515, 0.12814300499719553, 0.8557105720821774, 0.14003890615733164, 0.6244870145970732, -0.7357213421067638, 0.3668521657005066, 0.5081064687336281, 0.09722842261184794, 0.3222236083922749, 0.41627445425069787, -0.6650372267031625, 0.1820456773964445, 0.397777990076469, 0.15179077309830055, 0.6273135491336795, 0.31527112011663977, 2.385564773265742, 0.06718082805099321, -0.0009483063407804629, 0.46423196128973165, 0.9351668163954346, 1.042430544710671, 0.9637396922414376, 0.822061120691841, 0.9189563187156202, 1.0380391833031029, 0.2082828070728952, -0.7203450502897419, 0.4070860913170722, 0.5831022696691078, -0.9864255524957818, 1.0353906396722379, 0.10227332806908379, -0.003616565577232944, 0.10481798302745622, 0.1607951083706389, -1.2172143179108663, 0.5924733627371669, -0.023478724269617106, 1.2533841330952382, 0.4780702655150276, 0.301225600104104, 1.8684829341700135, 0.8130633276995304, 0.9633423816101383, 0.912006980574952, 0.3210798693755368, 0.06969746380719705, 1.197829185904624, 0.5980935012956275, 0.3597146096556576, 1.202409707635785, -0.08020172522714769, -0.13226974530102864, 1.235715043945553, 1.4109076697165495, 0.9849616562830316, 0.9011239769098943, 1.1200307347161076, 1.2897671470404517, 0.7735487719892011, 1.0809151445614829, 0.8867116779608343, 1.189177584689795, 0.5064981348297972, 0.7711394438806687, 0.6138422924500804, 0.8107603285267632, 0.5443920270690209, 1.1922237530293127, 0.5313063548071251, 1.1550141600910082, 1.1636780964672127, 0.5331716435416949, 0.920311588527667, 1.0031163386467905, 1.708313546967461, 1.0088511702702856, 1.0584830180503506, 0.5476823971533584, 1.1455636365120316, 1.2347233919900416, 0.814790163630538, 1.2462935517489628, 0.513758007036979, 0.45730430472801104, 0.2891529754170029, 0.4595507647476043, -0.048990071268207036, -0.023109178629715565, -0.11183119703900164, 0.745880201474842, 0.9053943966815722, 1.0184741750047, 0.5180834130711012, 0.7419414622810021, 0.6276110269386213]


weights_trial = []
loss_best = 100000000000000
itC = 0
species = 0
data_examples = 30000

# 6x6 neural network with a bias node for each layer. Rectified linear function will be used.


len_weights = 6*6*5
for i in range(0, len_weights):
    #weights.append(1)
    weights_trial.append(1)

len_nodes = 6*6
for i in range(0,len_nodes):
    nodes.append(0)



def sigmoid(x):
    if(x > 0):
        return x
    else:
        return 0


def ff(x_in, y_in, weights_in, nodes_in):
    nodes_in[0] = 1
    nodes_in[1] = x_in
    nodes_in[2] = y_in
    nodes_in[3] = 1
    nodes_in[4] = 1
    nodes_in[5] = 1

    for i in range(6,len_nodes):
        if(i % 6 == 0):
            nodes_in[i] = 1
        else:
            nodes_in[i] = 0
            for j in range(0, 6):
                # Add and weight all nodes in previous layer
                node_index = j + (i - i % 6) - 6
                weight_index = (i - 7) * 6 + j
                #print("node " + str(node_index) + " connected by " + str(weight_index) + " to " + str(i))
                nodes_in[i] += nodes_in[node_index] * weights_in[weight_index]
            nodes_in[i] = sigmoid(nodes[i])
    return nodes_in[-1]

#print(ff(1, 1, weights, nodes))

def extract_numbers_from_file(file_path):
    numbers = []
    try:
        with open(file_path, 'r') as file:
            for i, line in enumerate(file):
                if i >= data_examples:  # Process only the first 1000 lines
                    break

                parts = line.split()  # Split the line into parts
                
                # Extract and store the first three numbers
                try:
                    first_three_numbers = [float(parts[j]) for j in range(3)]
                    numbers.append(first_three_numbers)
                except (IndexError, ValueError):
                    print(f"Line {i + 1} is malformed or doesn't contain enough numbers.")

    except FileNotFoundError:
        print(f"File not found: {file_path}")

    return numbers

# Example usage
file_path = 'train_data.txt'  # Replace with your file path
extracted_numbers = extract_numbers_from_file(file_path)
#print(extracted_numbers)


def loss(nodes_in, weights_in):
    sum = 0
    for i in range(0, data_examples):
        x = extracted_numbers[i][0]
        y = extracted_numbers[i][1]
        a = extracted_numbers[i][2]
        a_guess = ff(x, y, weights_in, nodes_in)
        loss = ((a - a_guess) ** 2) / data_examples * 100
        sum += loss

    return sum

#print(loss(nodes, weights))

while True:
    #print(loss(nodes, weights))
    for i in range(0, len_weights):
        weights_trial[i] = weights[i]
    random_mag = 10 ** random.randint(-11, -1)
    for i in range(0, len_weights):
        if(random.uniform(0, 1) < 2 / len_weights):
            weights_trial[i] += random.uniform(-1,1) * random_mag
    
    #print(weights_trial)
    loss_trial = loss(nodes, weights_trial)
    if(loss_trial < loss_best):
        loss_best = loss_trial
        print("\n\n\n\n" + str(weights_trial))
        print("\n\n" + str(loss_best))
        for i in range(0, len_weights):
            weights[i] = weights_trial[i]

        species += 1
    itC += 1





