import random
import time

nodes = []

weights = [0.7951697281141393, 0.9619878577180923, 1.3109942515950677, 0.7184355220008398, 0.7232722421237143, 0.09994469771090214, 0.490413312817749, 1.0511058781852087, -0.4491346217399393, 0.06782237886908267, 0.05468701913521483, -0.5010639899671008, 0.3519648841294162, 0.3747335771030274, 0.5241140821977684, 0.26419092046237824, -0.08996954198619826, 0.7787694977414709, -0.05972087491383805, -0.07296495474556149, 1.80626980772892, 0.1520944337929071, -0.017264382006780887, -0.1624639596726414, -0.09657357854065672, 1.2745934463499378, 0.01441550890675306, 0.2815725746154119, -0.13420142951528632, -0.020442571010530403, 0.9971693780556247, 0.8200368176052032, 2.033437445866179, 0.9058324124176955, 1.1767364497183348, 0.9288932693020735, 0.6197724872873656, -0.4842329054337473, 0.3651644014070533, 0.5976902162609619, 0.25238375213130804, 0.9322967723311738, 0.09312472005486447, 0.13617806005289965, 0.7272393190089079, -0.1350946627481269, 0.6765557869022617, 0.21428727599378788, 0.8376900295127254, -0.536933337386093, 0.34036317857655685, -0.16389461760596835, 0.9520571420119223, 1.1998613210089735, 0.7529294195134641, -0.7234942021030266, 0.521966128640006, 1.0332009294656697, -0.07078801124568188, 0.45679264352147986, 0.746697070571959, 0.49084938398590117, 0.004801245786865537, 0.6706191504107887, 0.35678649385888944, 1.2171569846298527, 0.6646768595792438, 1.2075783830331672, 1.5176378075084997, 1.444184064317392, 0.5254983877584946, 1.0975987283701127, 1.2068983618550946, 1.2465436990303929, 0.12850443593673325, -0.16771659198946354, 0.21121672222108487, 0.36357555793419505, 0.2345955331069907, 0.0410770023347065, 0.5556698710155054, 2.340556119307453, 0.23831664500105637, 0.12751027003946228, 0.8641240818940589, 0.06679493929255158, 0.5485638457167995, -0.7187386830307937, 0.41097928886723645, 0.5104077614671508, 0.0958076997108218, 0.31443867791629027, 0.41681373011231876, -0.6712442110014618, 0.18203919822393433, 0.40411340894316433, 0.1508160369878017, 0.6275083593433346, 0.30745565434527206, 2.3979417190333505, 0.0759549034554379, -0.001898576403638763, 0.46486110072930953, 0.9352154918620884, 1.0432959480334065, 0.9693543336591339, 0.9126563137669145, 0.9181365174070142, 1.0301031326977008, 0.22242247034326512, -0.7194714130752042, 0.4074610595175742, 0.5866780519737675, -0.982067234680673, 1.0355998872150098, 0.1005781221111022, -0.005222158505370455, 0.11006202935553264, 0.1571946660132212, -1.2233171333887003, 0.595008909703907, -0.02829173768372854, 1.252843852573829, 0.47698962635413644, 0.29037673625555815, 1.9648408152076613, 0.7694907423971438, 0.9629295329717055, 0.9115266917531122, 0.3276423402409513, 0.0857593059189293, 1.1766736525186081, 0.6049943018911234, 0.3536974489697424, 1.2137151659344396, -0.06816611008060355, -0.12437410219164594, 1.2362405955341584, 1.40248063457785, 0.9858323165793095, 0.9011166777653787, 1.1249630318912536, 1.2005211116344203, 0.7719648754521206, 0.9926962708384729, 0.844421000956177, 1.1561119469519219, 0.5042274182984133, 0.7707274147986605, 0.6125232509034549, 0.8109921396338337, 0.6165996324462598, 1.1921947904842185, 0.5359543325826164, 1.1549576356540192, 1.1637399343128856, 0.5332291223967237, 0.9196712326856707, 1.060533438082242, 1.7107121926355153, 1.0677414739516087, 1.0551790792862743, 0.5420234370244449, 1.1444609047821894, 1.2371070838736318, 0.8147822417241458, 1.2385986013015122, 0.5144253055339828, 0.453678173820367, 0.2888096278985436, 0.4595486585963284, -0.049725574546214124, -0.023150820150428134, -0.11175375980825183, 0.745481813269033, 0.9053944080961156, 1.0185516562967318, 0.517945313850324, 0.7411615690373695, 0.6269423807914318]
weights_trial = []
loss_best = 100000000000000
itC = 0
species = 0
data_examples = 10000

# 6x6 neural network with a bias node for each layer. Rectified linear function will be used.


len_weights = 6*6*5
for i in range(0, len_weights):
    #weights.append(1)
    weights_trial.append(1)

len_nodes = 6*6
for i in range(0,len_nodes):
    nodes.append(0)



def sigmoid(x):
    if(x > 0):
        return x
    else:
        return 0


def ff(x_in, y_in, weights_in, nodes_in):
    nodes_in[0] = 1
    nodes_in[1] = x_in
    nodes_in[2] = y_in
    nodes_in[3] = 1
    nodes_in[4] = 1
    nodes_in[5] = 1

    for i in range(6,len_nodes):
        if(i % 6 == 0):
            nodes_in[i] = 1
        else:
            nodes_in[i] = 0
            for j in range(0, 6):
                # Add and weight all nodes in previous layer
                node_index = j + (i - i % 6) - 6
                weight_index = (i - 7) * 6 + j
                #print("node " + str(node_index) + " connected by " + str(weight_index) + " to " + str(i))
                nodes_in[i] += nodes_in[node_index] * weights_in[weight_index]
            nodes_in[i] = sigmoid(nodes[i])
    return nodes_in[-1]

#print(ff(1, 1, weights, nodes))

def extract_numbers_from_file(file_path):
    numbers = []
    try:
        with open(file_path, 'r') as file:
            for i, line in enumerate(file):
                if i >= 1000:  # Process only the first 1000 lines
                    break

                parts = line.split()  # Split the line into parts
                
                # Extract and store the first three numbers
                try:
                    first_three_numbers = [float(parts[j]) for j in range(3)]
                    numbers.append(first_three_numbers)
                except (IndexError, ValueError):
                    print(f"Line {i + 1} is malformed or doesn't contain enough numbers.")

    except FileNotFoundError:
        print(f"File not found: {file_path}")

    return numbers

# Example usage
file_path = 'train_data.txt'  # Replace with your file path
extracted_numbers = extract_numbers_from_file(file_path)
#print(extracted_numbers)


def loss(nodes_in, weights_in):
    sum = 0
    for i in range(0, data_examples):
        x = extracted_numbers[i][0]
        y = extracted_numbers[i][1]
        a = extracted_numbers[i][2]
        a_guess = ff(x, y, weights_in, nodes_in)
        loss = ((a - a_guess) ** 2) / data_examples * 100
        sum += loss

    return sum

#print(loss(nodes, weights))

while True:
    #print(loss(nodes, weights))
    for i in range(0, len_weights):
        weights_trial[i] = weights[i]
    random_mag = 10 ** random.randint(-11, -1)
    for i in range(0, len_weights):
        if(random.uniform(0, 1) < 2 / len_weights):
            weights_trial[i] += random.uniform(-1,1) * random_mag
    
    #print(weights_trial)
    loss_trial = loss(nodes, weights_trial)
    if(loss_trial < loss_best):
        loss_best = loss_trial
        print("\n\n\n\n" + str(weights_trial))
        print("\n\n" + str(loss_best))
        for i in range(0, len_weights):
            weights[i] = weights_trial[i]

        species += 1
    itC += 1





